# lock-sample
开发中使用到的锁概念

## 1、乐观锁

乐观锁总是假设最好的情况，认为共享的资源每次被访问的时候都没有人修改，只是在提交修改的时候
去验证对应的资源（也就是数据）是否被其它线程修改了

实现方法有使用版本号机制、CAS 算法

### 版本号机制

版本号机制一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，比较读取到的 version 值与当前数据库中的 version 值是否相等，相等时才更新，否则重试操作。

### CAS算法

CAS的思想就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。C#中 **Interlocked** 类

依赖：CPU的原子指令

CAS 涉及到三个操作数：

- V：要更新的变量值(Var)

- E：预期值(Expected)

- N：拟写入的新值(New)

当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。需要注意ABA问题


## 2、悲观锁

悲观锁总是假设最坏的情况，认为共享的资源每次被访问的时候别人会修改，所以每次在拿数据的时候都会上锁，直到使用完被释放。
先取锁再访问：悲观锁中的共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程

C#可以使用：`synchronized`、`lock`等


## 3、互斥锁
互斥锁加锁失败后，线程会释放 CPU ，给其他线程；
C#实现：Mutex

## 4、自旋锁
自旋锁加锁失败后，线程会忙等待，直到它拿到锁；
C#实现：SpinLock

## 5、混合锁
混合锁混合了自旋锁和互斥锁。刚开始会像自旋锁一样，先重试一定的次数；超过这个次数之后将线程设置为等待状态
C#实现：Monitor | lock

## 6、读写锁

## 6、分布式锁